<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>php</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="highlights/styles/atom-one-dark.css">
    <script src="highlights/highlight.pack.js"></script>
    <script>hljs.highlightAll();</script>
</head>
<body>
<h1>INFO</h1>
<p>By 1T0S_</p>
<p>Úprava textu:</p>
<ul>
    <li>Normální text</li>
    <li class="code">Kód</li>
    <li><i>Zvýraznění</i></li>
</ul>

<h1>Rozdíly oproti jiným jazykům</h1>
<p>
    Php funguje na stejném principu, jako ostatní jazyky, takže jej zde nebudu vypisovat. Dost se však liší v syntaxi.
</p>
<h2>1. Proměnné, stringy</h2>
<h3>1.1 Proměnné</h3>
<p>
    Proměnné se v php tvoří zápisem <i>$proměnná</i>. Jsou deklarovány v momentě, kdy jim je přiřazena hodnota.
    Též jsou dynamicky typované, takže není potřeba určovat datový typ. Typ proměnné lze zjistit pomocí funkce
    <i>gettype(<i>$proměnná</i>)</i>, což se může hodit při debugu.
</p>
<h3>1.2 Stringy</h3>
<p>
    Stringů je v php několik druhů ($jmeno = "Damian"):
</p>
<ul>
    <li>
        <i>'single quoted string'</i> -> Ani proměnné, ani escape sequence nejsou expandovány, takže při zadání stringu
        <i>'Ahoj, $jmeno\t:)'</i> dojde k výpisu <i>Ahoj, $jmeno\t:)</i>.
    </li>
    <li>
        <i>"double quoted string"</i> -> Dochází k expandování proměnných a escape sequencí. Při zadání stringu
        <i>"Ahoj, $jmeno\t:)"</i> dojde k výpisu <i>Ahoj, Damian &emsp; :)</i>
    </li>
</ul>

<h2>2. Foreach</h2>
<p>
    PHP má oproti ostatním jazykům syntakticky jiný foreach.
</p>
<pre><code class="php">
    foreach(<i>$array</i> as <i>$variable</i>){
        echo("<i>$variable</i>");
    }
    </code>
</pre>

<h2>3. Array</h2>
<p>
    PHP má více druhů arrayů.
</p>
<p>
    Tím prvním je klasický indxovaný array. Definuje se standardně (příklad), pracuje se s ním jako s polem.
</p>
<pre><code class="php">
    $znamky = [1, 1, 3, 2, 2, 4];
    echo($znamky[2]);
    // Vrátí hodnotu 3
    </code>
</pre>
<br>

<p>
    Dalším je asociativní array. Funguje jako Hash mapa, tedy na principu key -> value.
</p>
<pre><code class="php">
    $capitals = ["England" => "London", "Hungary" => "Budapest", "Czechia" => "Prague"];
    echo($capitals["Hungary"];
    // Vrátí hodnotu "Budapest"
    </code>
</pre>
<br>

<p>
    Posledním je multidimenzionální array (AKA Array, který má v sobě další Arraye).
</p>
<pre><code class="php">
    $mark = [
    "Alex" => [
    "biology" => 73,
    "history" => 85
    ],
    "Jim" => [
    "biology" => 86,
    "history" => 92
    ]
    ];

    echo $mark["Jim"]["history"];
    // Vrátí hodnotu 92
    </code>
</pre>

<br>
<h1>Objektově orientované programování</h1>
<p>OOP v PHP je principiálně podobné Javě, liší se však syntaxí.</p>
<h2>1. Třídy a objekty</h2>
<p>
    Třídy se tvoří keywordem <i>class</i>. Každá třída by měla obsahovat seznam proměnných (atributů), míru jejich
    zapouzdření (public, private, protected), metody, konstruktor a gettery/settery.
</p>
<p>Objekty se tvoří pomocí řádky <i>$jmenoObjektu = new Trida();</i></p>
<p>K parametrům objektu se přístupuje pomocí šipky. <i>objekt->metoda();</i></p>
<p>K statickým proměnnám třídy se přistupuje pomocí <i>Trida::$proměnná</i></p>
<p>
    Klíčové slovo <i>$this</i> se používá pro přístup k současnému objektu, klíčové slovo
    <i>self</i> se používá k přístupu k současné třídě.
</p>

<h2>2. Konstruktor</h2>
<p>
    Konstrktor se v php tvoří pomocí magické metody <i>__construct($params)</i>.
</p>

<h2>NoContextMagickéMetody</h2>
<p>
    Magické metody jsou metody, které již v php v základu existují. Jejich definováním je však lze přepsat a tím jim
    dát jiný efekt. Příkladem může být konstruktor (<i>__construct($params)</i>), který při přepsání může například
    ovlivňovat statické proměnné třídy či nastavovat hodnoty objektu.
</p>

<h2>3. Gettery, settery</h2>
<p>
    Gettery a settery se používají k přístupu k private a protected atributům objektu. V php lze gettery a settery
    tvořit jak klasicky, tak pomocí magických metod <i>__get()</i> a <i>__set()</i>. Je možné použít oba styly, záleží
    na preferencích.
    <a href="https://stackoverflow.com/questions/6184337/best-practice-php-magic-methods-set-and-get">
        STACK OVERFLOW THREAD
    </a>
</p>

<h2>4. Příklad</h2>
<pre><code class="php">
    class Person{
    private $name;
    private $age;
    private static $count;

    // Konstruktor, používá magickou metodu __construct
    function __construct($name, $age){
    // Přístup k objektu pomocí $this->proměnná
    $this->name = $name;
    $this->age = $age;
    // Přístup ke classe pomocí self::$proměnná
    self::$count += 1;
    }

    // Metoda objektu
    public function pozdrav(){
    echo "Ahoj, jmenuju se $this->name a je mi $this->age let!";
    }

    // Statická metoda třídy
    public static function pocetLidi(){
    return "Celkem bylo vytvořeno " . self::$count . " lidí!";
    }

    // Normální gettery a settery
    public function getName(){
    return $this->name;
    }

    public function getAge(){
    return $this->age;
    }

    public function setName($val){
    $this->name = $val;
    }

    public function setAge($val){
    $this->age = $val;
    }
    }
    </code>
</pre>

<br>
<h1>Zpracovávání formulářů</h1>
<p>Formuláře se v php zpracovávají s pomocí superglobálních proměnných _GET a _POST.</p>
<h2>1. Formuláře - HTML část</h2>
<p>
    Formuláře jsou tvořeny v html. Jakýkoli formulář je uvozen tagem <i>form</i>, který obsahuje parametry <i>action</i>
    (název na skript, který se po odeslání formuláře zavolá) a <i>method</i> (metoda, pomocí které budou data zaslána
    [může být post/get]). Uvnitř formuláře se nacházejí tagy <i>input</i>, které mají parametr <i>type</i>. Druhy typů:
</p>
<ul>
    <li><i>text</i> -> Textové pole <input type="text"/></li>
    <li><i>radio</i> -> Radio button <input type="radio"/><input type="radio"/></li>
    <li><i>checkbox</i> -> Zaškrtávací pole <input type="checkbox"/></li>
    <li><i>button</i> -> Tlačítko <input type="button" name="tlacitko" value="tlacitko"></li>
    <li><i>submit</i> -> Tlačítko k odeslání formuláře <input type="submit"/></li>
</ul>
<p>Veškeré prvky by měly mít <i>id, name, value</i>.
<p><a href="php_examples/numbers.php">Příklad funkčního html formu -> Right click -> Inspect</a></p>

<h2>2. Formuláře - PHP část</h2>
<p>
    Po odeslání dat pomocí html formu je nyní potřeba je zpracovat. To se dělá pomocí php. Prvním krokem je obvykle
    získání dat ze superglobální proměnné <i>$_GET</i> či <i>$_POST</i>.
</p>
<p>
    <i>$_GET</i> posílá parametry přes URL, <i>$_POST</i> přes HTTP message. <i>$_POST</i> je pomalejší, ale
    <i>na rozdíl od $_GET BEZPEČNÝ</i>, tudíž se používá pro přenos citlivých dat.
</p>
<p style="color: red; font-weight: bold;">
    Inputy je potřeba validovat a ošetřit, aby se nedaly napadnout (například XSS, SQL Injection, Code Injection,
    Session fixation...). Google that shit -> Zde jen zápis syntaxe a jednoduché appky, která nebude ošetřena.
</p>
<p>
    Rozdíl mezi funkcemi <i>isset()</i> a <i>empty()</i>
</p>
<ul>
    <li><i>isset()</i> -> Zkouší, jestli má proměnná hodnotu (není null). Pokud tomu tak je, vrací true.</li>
    <li><i>empty()</i> -> Zkouší, jestli má proměnná hodnotu "", 0, false či NULL. Pokud tomu tak je, vrací true.</li>
</ul>
<p>
    Vytažení hodnoty z proměnné <i>$_POST:</i>
</p>
<pre>
    <code class="php">
        if (!empty($_POST['email'])) {
            $email = $_POST['email'];
        }
    </code>
</pre>

<br>
<h1>Sessions a protokol HTTP</h1>
<h2>1. Způsob fungování</h2>
<p>
    Protokol HTTP funguje na jednoduché bázi -> Server pošle klientovi stránku s danými daty. Občas je ovšem potřeba
    posílat každému klientovi jinou stránku (jakékoli stránky po loginu). K tomu se používají php sessions.
</p>
<h2>2. PHP Sessions</h2>
<p>
    Při použití sessionů je každému uživateli přiřazeno unikátní ID. Toto ID je uloženo jak na webovém serveru, tak u
    klienta (v podobě cookie souboru v prohlížeči). Při přístupu klienta k webové stránce je kontrolováno, jestli
    jej server už nezná (klient id neodpovídá některému z id na serveru). Pokud jej zná, je mu přiřazena jeho již
    existující session. Pokud jej nezná, je vytvořená nová session.
</p>
<p>
    <i>$_SESSION</i> je superglobální array, do kterého je možné ukládat informace, které by jednotliví klienti
    mohli využít.
</p>
<h2>3. Příklad použití</h2>
<p>
    Příklad, který počítá s $_POSTem jména, emnailu a věku. Není nijak ošetřen.
</p>
<pre><code class="php">
// create_session.php
session_start();
if(isset($_SESSION["name"]) && isset($_SESSION["email"])){
    $_SESSION["counter"] += 1;
    header("Location: session_output.php");
} else{
    $_SESSION["name"] = $_POST["name"];
    $_SESSION["email"] = $_POST["email"];
    $_SESSION["age"] = $_POST["age"];
    $_SESSION["counter"] = 1;
    header("Location: session_output.php");
}
</code></pre>
<p>
    Na začátku dojde ke spuštění sessionu. Pokud je uživatle na stránce poprvé (-> na serveru se nenachází soubor s jeho
    session ID, který by obsahoval hodnoty jména a emailu), jsou v <i>$_SESSION</i> vytvořeny nové záznamy, které obsahují
    údaje o něm. Pokud uživatel stránku již někdy navštívil (-> php
    je schopno najít jeho údaje v proměnné <i>$_SESSION</i>), dojde pouze k inkrementaci počtu návštěv.
</p>
<br>
<p>
    Pokračování příkladu: výpis na webovou stránku.
</p>
<pre><code class="php">
// session_output.php;
session_start();
echo("Uživatel: " . $_SESSION["name"]) ;
echo("Věk: " . $_SESSION["age"]);
echo("Email: " . $_SESSION["email"]);
echo("Počet návštěv: " . $_SESSION["counter"]);
?>
</code></pre>
<p>
    Na začátku opět dojde ke spuštění sessionu. Jelikož je tato stránka načtena okamžitě po minulém příkladu, proměnné
    o uživateli se v sessionu stoprocentně nachází (eh, pokud nemá v browseru vyplé cookies), tudíž dojde k vypsání
    jeho údajů.
</p>
<p>
    <a href="http://www.pehapko.cz/programujeme-v-php/sessions">Podrobný článek o sessions.</a>
</p>

<br>
<h1>Připojení k databázi</h1>
<h2>1. PDO vs. Mysqli</h2>
<p>
    K připoejní k databázi se v php dá použít více controllerů. Jedním z nich je třeba PDO, druhým Mysqli. PDO funguje s
    více než 12 různými databázemi, Mysqli pouze s jednou (kterou je kupodivu... MYSQL!). Oba controllery jsou objektové
    a nabízí spoustu funkcí (předpřipravené statementy, ochrana před sql injection...).
</p>
<p>
    V maturitní otázce je zmíněn PDO ovladač, takže... PDO.
</p>

<h2>2. Připojení k databázi pomocí PDO</h2>
<p>
    Pro připojení k databázi jsou obecně potřeba nejméně čtyři údaje: jméno serveru (servername), jméno uživatele
    (username) a heslo (password) a jméno databáze.
</p>
<p>
    Příklad připojení k databázi pomocí PDO:
</p>
<pre>
    <code class="php">
        $servername = "linuxServer";
        $username = "root";
        $password = "password";
        $database = "gentoo";
        // Vaše ubuntu bylo napadeno

        try {
          $conn = new PDO("mysql:host=$servername;dbname=$database", $username, $password);
          // set the PDO error mode to exception
          $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
          echo "Connected successfully";
          /*
                ZDE BUDE POKRAČOVÁNÍ KÓDU
          */
        } catch(PDOException $e) {
          echo "Connection failed: " . $e->getMessage();
        }
    </code>
</pre>

<h2>3. Queries pomocí PDO</h2>
<p>
    Pro práci s databází je potřeba queries. Ty se dají v PDO spouštět pomocí metody <i>exec($string)</i>.
</p>
<p>
    Příklad spouštění dotazů:
</p>
<pre>
    <code class="php">
        /*
                Pokračování
        */

        $sql = "CREATE TABLE os(
            id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
            name VARCHAR(30) NOT NULL,
            age INT NOT NULL
        )";
        $conn->exec($sql);
        echo("Tabulka byla vytvořena");

        $sql = "INSERT INTO os(name, age) VALUES
            (\"Gentoo\", 20),
            (\"TempleOS\", 9),
            (\"Arch Linux\", 23)";
        $conn->exec($sql);
        echo("Přidány záznamy");
    </code>
</pre>

<h2>4. Prepared statements</h2>
<p>
    Prepared statements (předpřipravené dotazy?) se používají při práci s uživatelským vstupem, protože zabraňují
    SQL injekcím. Obvykle nejprve dojde k vytvoření statementu s obecnými hodnotami, kterému jsou později přidávány
    hodnoty konkrétní.
</p>
<p>Příklad:</p>
<pre>
    <code class="php">
        $servername = "linuxServer";
        $username = "root";
        $password = "password";
        $database = "gentoo";
        // Vaše ubuntu bylo napadeno

        try {
            $conn = new PDO("mysql:host=$servername;dbname=$database", $username, $password);
            // set the PDO error mode to exception
            $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

            // Příprava statementu a bindování parametrů
            $statement = $conn->prepare("INSERT INTO os(name, age) VALUES (:name, :age);");
            $statement->bindParam(":name", $name);
            $statement->bindParam(":age", $age);

            $name = "Linux Mint";
            $age = 11;
            $statement->execute();

            $name = "Ubuntu";
            $age = 17;
            $statement->execute();

            echo("Dva záznamy přidány");

        } catch(PDOException $e){
            echo("Error: " . $e->getMessage());
        }
    </code>
</pre>
<p>
    V základu se vytvoří predpřipravený statement s označenými parametry (<i>:name, :age</i>), které se později pomocí
    metody <i>bindParam("parametr", $proměnná)</i> spojí s proměnnými. Metoda <i>execute()</i> následně spustí daný
    dotaz s parametry, které se nacházejí v nabindovaných proměnných.
</p>

<h2>5. SELECT</h2>
</body>
</html>