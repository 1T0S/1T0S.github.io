<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Databáze</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
<h1>INFO</h1>
<p>By 1T0S_</p>
<p>Úprava textu:</p>
<ul>
    <li>Normální text</li>
    <li class="code">Kód</li>
    <li><i>Názva proměnných, tabulek či databází v kódu</i></li>
    <li><b>Zvýraznění důležitých informací v textu či kódu</b></li>
</ul>

<br>
<h1>Základy databází</h1>
<h2>1. Co jsou to databáze?</h2>
<p>
    Databáze jsou systémy, které se používají k ukládání dat. Databází může být pro příklad accessová tabulka,
    tištěný seznam, excelová tabulka či kniha. Všechny tyto způsoby jsou ovšem neefektivní pro ukládání většího
    množství dat, proto byly vymyšleny Database Management Systémy.
</p>

<h2>2. Database Management System</h2>
<p>
    DBMS je software, který se stará o provádění operací s daty v databázi. Mezi v současnosti nejpoužívanější
    DBMS patří MySQL, PostgreSQL, MongoDB či Oracle.
</p>
<p>
    Operace, které DBMS provádí, se nazývají CRUD.
</p>
<ul>
    <li>Create - Přidávání dat do databáze</li>
    <li>Read - Čtení dat z databáze</li>
    <li>Update - Měnění dat v databázi</li>
    <li>Delete - Mazání dat z databáze</li>
</ul>
<h3>2.1 Databázové enginy</h3>
<p>Databázový engine je část Database Management Systému, která se stará o provádění CRUD operací. Pro DBMS, který
    používáme (MySql), existují dva důležité databázové enginy - InnoDB a MyISAM. Tyto enginy mají několik rozdílů:</p>
<ul>
    <li>MyISAM <b>nepodporuje</b> transakce, InnoDB ano</li>
    <li>MyISAM <b>nepodporuje</b> cizí klíč, InnoDB ano</li>
    <li>InnoDB <b>nepodporuje</b> FULLTEXT, MyISAM ano</li>
</ul>

<h2>3. Druhy databází</h2>
<p>
    Databázové systémy se dělí na dva druhy - relační a nerelační.
</p>
<p>
    Relační databázové systémy ukládají data do tabulek a k provádění CRUD operací používají standardizovaný jazyk SQL.
</p>
<p>
    Nerelační databázové systémy jsou ty, které data do tabulek neukládají = používají jiný způsob ukládání dat.
    Nemají žádný standardizovaný způsob pro provádění CRUD operací, tudíž se liší jak v implementaci, tak práci s nimi.
</p>

<h2>4. Relační databáze</h2>
<p>
    Data v relačních databázích jsou ukládána do tabulek. Jedna databáze má obvykle větší množství tabulek.
</p>
<p>Některé pojmy relačních databází:</p>
<ul>
    <li>Atribut - Sloupec tabulky</li>
    <li>Záznam - Řádek tabulky</li>
    <li>Primární klíč - Unikátní atribut, který jednoznačně označuje záznam v tabulce. Klíč se může skládat z jednoho
        či více sloupců tabulky
    </li>
    <li>Cizí klíč - Atribut, který označuje primární klíč jiné (výjimečně i stejné) tabulky. Jedna tabulka může
        mít více cizích klíčů
    </li>
</ul>

<h2>5. SQL</h2>
<p>
    SQL je zkratka pro Structured Query Language. Používá se pro interakci s DBMS.
    Používá se k:
</p>
<ul>
    <li>Provádění CRUD operací</li>
    <li>Tvoření a správu tabulek a databází</li>
    <li>Administrativním úlohám (export, import, zabezpečení...)</li>
</ul>
<p>
    SQL je standardizovaným jazykem, ovšem ne všechny implementace DBMS tento standard dodržují. Základy implementací
    jsou však zpravidla shodné či velice podobné.
</p>
<h3>5.1. Dotazy</h3>
<p>
    Dotaz (query) je set instrukcí, který se používá pro vykonání určité operace.
</p>

<br>
<h1>Tvorba tabulek, zadávání a manipulace hodnot</h1>
<h2>1. Setup</h2>
<p>
    Pro práci se bude používat XAMPP MySql, konkrétně webový interface localhost/phpmyadmin.
</p>

<h2>2. Datové typy</h2>
<p>
    V databázích se používá velké množství datových typů, zvolení správného datového typu optimalizuje databázi.
    Příklady datových typů:
</p>
<ul>
    <li>INT - Celé číslo</li>
    <li>DECIMAL / FLOAT / DOUBLE - Desetinné číslo</li>
    <li>VARCHAR(VELIKOST) - Řetězec</li>
    <li>BLOB - Velké binární objekty, například obrázky</li>
    <li>DATE - Ukládání data ve formátu yyyy-mm-dd</li>
    <li>TIMESTAMP - Ukládání času ve formátu YYYY-MM-DD HH:MM:SS</li>
</ul>

<h2>3. Tvoření tabulek</h2>
<p>
    Tabulky se dají vytvořit přes grafické rozhraní phpmyadmin či přes SQL.
    Syntaxe SQL dotazu pro vytvoření tabulky:
</p>
<p class="code">
    CREATE TABLE <i>jmeno</i> (<i>jmenoSloupce</i> <b>datovyTyp</b>,
    <i>jmenoSloupce</i> <b>datovyTyp</b> ... );
</p>
<p>
    Příklad, který vytvoří tabulku s int id, string jménem a přijmením:
</p>
<p class="code">
    CREATE TABLE <i>person</i> (
    <i>person_id</i> INT PRIMARY KEY NOT NULL,
    <i>first_name</i> VARCHAR(20),
    <i>last_name</i> VARCHAR(20)
    );
</p>
<p>
    Vytvoří tabulku:
</p>
<table>
    <tr>
        <th>person_id</th>
        <th>first_name</th>
        <th>last_name</th>
    </tr>
</table>
<h3>3.1 Constraints aneb jak se to sakra překládá</h3>
<p>
    Při tvorbě tabulky je možno nastavit chování jednotlivých sloupců, a to například nastavením defaultní hodnoty či
    zakázáním NULL hodnoty. K tomu slouží constraints, které se píší za datový typ sloupce.
</p>
<p>Příklad syntaxe constraints při tvoření tabulky:</p>
<p class="code">
    CREATE TABLE <i>person</i>(
    <i>person_id</i> INT PRIMARY KEY NOT NULL,
    <i>first_name</i> VARCHAR(20) DEFAULT "Damian",
    <i>last_name</i> VARCHAR(20) NOT NULL
    )
</p>
<p>Tato tabulka bude mít int primární klíč, string jméno, které při nezadání hodnoty bude "Damian", a string
    přijmení, které bude nutno zadat, jinak se dotaz neprovede.</p>
<p>List obvykle používaných constraintů:</p>
<ul>
    <li>NOT NULL - Ujistí se, že sloupec má hodnotu, pokud tomu tak není, vyhodí error</li>
    <li>UNIQUE - Ujistí se, že sloupec má unikátní hodnotu (hodnota, která se v něm nachází, není v žádném jiném
        záznamu)
    </li>
    <li>PRIMARY KEY - Primární klíč, woooow!</li>
    <li>DEFAULT <b>val</b> - Pokud není specifikována hodnota sloupce, nastaví ji na <b>val</b></li>
    <li>CHECK <b>(podmínka)</b> - Ujistí se, že zadávaná hodnota splňuje podmínku</li>
    <li>FOREIGN KEY - Reference řádku jiné tabulky</li>
</ul>
<p>Foreign key se zapisuje syntaxí:</p>
<p class="code">.....<br>
    FOREIGN KEY(<i>jmenoSloupce</i>) REFERENCES <i>jmenoCiziTabulky</i>(<i>jmenoSloupceVCiziTabulce</i>);
</p>

<h2>4. Mazání tabulek</h2>
<p>
    Tabulky se dají smazat pomocí snadného příkazu:
</p>
<p class="code">
    DROP TABLE <i>jmenoTabulky</i>;
</p>

<h2>5. Modifikace tabulek</h2>
<p>
    Již existující tabulky lze modifikovat, například přidáním či odebráním sloupce nebo změnou datového typu sloupce.
</p>
<p class="code">ALTER TABLE <i>jmenoTabulky</i> ADD <i>jmenoSloupce</i> <b>datovyTyp</b></p>
<p class="code">ALTER TABLE <i>jmenoTabulky</i> DROP COLUMN <i>jmenoSloupce</i></p>
<p class="code">ALTER TABLE <i>jmenoTabulky</i> ALTER COLUMN <i>jmenoSloupce</i> <b>datovyTyp</b></p>

<h2>6. Přidávání dat do tabulky</h2>
<p>
    Po vytvoření tabulky je potřeba ji naplnit daty. To se obvykle nedělá manuálně, ale za pomocí skriptu či programu.
    Syntaxe sql dotazu pro přidání záznamu do tabulky:
</p>
<p class="code">INSERT INTO <i>jmenoTabulky</i> VALUES(<b>hodnoty</b>);</p>
<p>Příklad, který přidá člověka Pepe Gun s id 0:</p>
<p class="code">
    INSERT INTO <i>person</i> VALUES(0, "Pepe", "Gun");
</p>
<p>Příklad, který přidá člověka Damian s id 1. Příjmení je neznámé, tudíž NULL</p>
<p class="code">
    INSERT INTO <i>person</i>(id, first_name) VALUES (1, "Damian");
</p>

<h2>7. Měnění dat v tabulce</h2>
<h3>7.1. Měnění dat</h3>
<p>Data v tabulce se dají měnit pomocí webového rozhraní phpmyadmin či SQL.</p>
<p>Pro měnění dat se používá příkaz UPDATE:</p>
<p class="code">
    UPDATE <i>jmenoTabulky</i> SET <i>jmenoAtributu</i> = <b>hodnota</b> WHERE <b>podminka</b>;
</p>
<p>Příklad, který změní všechny lidi, kteří se jmenují "Pepa", na "Damián"</p>
<p class="code">
    UPDATE <i>person</i> SET <i>first_name</i> = "Damian" WHERE <i>first_name</i> = "Pepa";
</p>
<h3>7.2. Mazání záznamů</h3>
<p>Na podobném principu funguje příkaz na mazání řádků tabulky:</p>
<p class="code">
    DELETE FROM <i>jmenoTabulky</i> WHERE <b>podminka</b>;
</p>
<p>Příklad, který smaže všechny, kteří se jmenují Damian</p>
<p class="code">
    DELETE FROM <i>person</i> WHERE <i>first_name</i> = "Damian";
</p>

<br>
<h1>Získávání dat z databáze</h1>

<h2>1. Dotazy</h2>
<p>
    Dotazy (queries) jsou způsobem, jak z databáze dostat data. Pro tvorbu dotazů, které tahají data z databáze,
    se používá příkaz SELECT
</p>
<p>Základní tvar příkazu SELECT, který vybere veškeré záznamy z dané tabulky:</p>
<p class="code">SELECT * FROM <i>jmenoTabulky</i>;</p>
<p>Hvězdička může být vyměněna za konkrétní sloupce, které chceme dotazem získat.</p>
<p>Příklad dotazu, který vybere jména a přijmení z tabulky person:</p>
<p class="code">SELECT <i>name</i>, <i>surname</i> FROM <i>person</i>;</p>

<h2>2. Třízení</h2>
<p>Výsledky, které dotaz vrátí, je možno třídit pomocí ORDER BY:</p>
<p class="code">SELECT * FROM <i>jmenoDatabaze</i> ORDER BY <i>jmenoSloupce</i>, <i>jmenoSloupce, ...</i>;</p>
<p>
    Třídit lze dle většiny datových typů. V základu jsou data třízena vzestupně (0...∞, A...Z), přidáním keywordu
    <b>DESC</b> za název sloupce však lze třídit i sestupně.
</p>
<p>Příklad, který vybere jména a věk z databáze a tato data následně setřídí sestupně:</p>
<p class="code">SELECT <i>name</i>, <i>age</i> FROM <i>person</i> ORDER BY <i>age</i> DESC, <i>name</i> DESC;</p>

<h2>3. Limitování</h2>
<p>Počet výsledků, které dotaz zobrazí, je možno omezit příkazem <b>LIMIT</b>:</p>
<p class="code">SELECT * FROM <i>databaze</i> LIMIT <i>n</i>;</p>
<p>Tento příkaz vypíše pouze <i>n</i> prvků z <i>tabulky</i></p>

<h2>4. Podmínky</h2>
<p>
    Vracet všechny záznamy tabulky nemá smysl, proto jsou tu podmínky. Pomocí příkazu <b>WHERE</b> lze omezit, jaké
    sloupce budou vráceny.
</p>
<p>Vzorový tvar dotazu s WHERE:</p>
<p class="code">SELECT * FROM <i>tabulka</i> WHERE <b>podminka</b>;</p>
<p>Podmínek může být více, spojují se pak logickými operátory:</p>
<p class="code">SELECT * FROM <i>tabulka</i> WHERE <b>podminka</b> <i>logickyOperator</i>
    <b>podminka</b> <i>logickyOperator</i> <b>podminka</b>....;</p>
<p>List často používaných operátorů:</p>
<ul>
    <li><b> >, <, <=, >=, =, <> </b> Operátory porovnání</li>
    <li><b>AND, OR</b> Základní logické operátory</li>
    <li><b>IN, BETWEEN, LIKE</b> Používány pro složitější podmínky</li>
</ul>
<p>Příklady:</p>
<p class="code">SELECT * FROM <i>person</i> WHERE <i>age</i> BETWEEN 20 AND 80</p>
<p class="code">SELECT * FROM <i>person</i> WHERE <i>surname</i> IN ("Net", "Bruh")</p>
<p class="code">SELECT * FROM <i>person</i> WHERE <i>name</i> LIKE "M%a"</p>
<p>(Protože je to docela mess, třetí query vrátí řádky, kde jméno začíná na <b>M</b> a končí na <b>a</b></p>

<h2>5. Funkce</h2>
<p>
    Místo záznamů z tabulky může dotaz vracet i jiné hodnoty, například průměr daného sloupce.
    K tomu se využívají SQL funkce.
</p>
<p>
    Funkce fungují stejně jako výběrové dotazy, akorát je místo sloupců, které chceme vybrat, zadána funkce.
</p>
<p>Obecný tvar:</p>
<p class="code">SELECT <i>FUNKCE(<b>parametry</b>)</i> FROM <i>tabulka</i>;</p>
<p>Příklad, který vypíše průměrný věk lidí v tabulce:</p>
<p class="code">SELECT AVG(<i>age</i>) FROM <i>person</i>;</p>
<h3>5.1. Často používané funkce</h3>
<ul>
    <li><b>COUNT(*)</b> - Vypíše počet záznamů ve sloupci</li>
    <li><b>SUM(*)</b> - Součet hodnot ve sloupci</li>
    <li><b>AVG(*)</b> - Průměr hodnot ve sloupci</li>
    <li><b>MAX(*)</b> - Nejvyšší hodnota ve sloupci</li>
    <li><b>MIN(*)</b> - Nejnižší hodnota ve sloupci</li>
</ul>
<p>(Za hvězdičku lze doplnit název jakéhokoli sloupce)</p>

<h2>6. Agregace</h2>
<p><b>Tohle je mess, nejsem si tím jistý</b></p>
<p>Agregace jsou dotazy, které kombinují funkce a výpis jednotlivých řádků.</p>
<p>Obecný tvar agregace:</p>
<p class="code">SELECT <b>FUNKCE(<i>sloupec</i>)</b>, <i>sloupec</i> FROM <i>jmenoTabulky</i> GROUP BY <i>sloupec</i>;
</p>
<br>
<p>Příklad, který vypíše, kolik jednotliví lidé vydělali:</p>
<p class="code">SELECT <i>name</i>, <b>SUM(<i>price</i>)</b> FROM <i>stonks</i> GROUP BY <i>name</i>;</p>
<p>Tento příklad poskytne výpis:</p>
<table>
    <tr>
        <th>name</th>
        <th>SUM(price)</th>
    </tr>
    <tr>
        <td>Damian</td>
        <td>420000</td>
    </tr>
    <tr>
        <td>Pepa</td>
        <td>50000</td>
    </tr>
    <tr>
        <td>Arnošt</td>
        <td>666666</td>
    </tr>
</table>

<h2>7. Wildcards</h2>
<p>Wildcards jsou jako regexy z Wishe - používají se pro vyhledávání pomocí řetězců. Jejich implementace se mohou
u jednotlivých druhů databází lišit. Tl;Dr na této stránce je vypracováno pro MySql.</p>
<p>Obecná syntaxe:</p>
<p class="code">SELECT * FROM <i>jmenoDatabaze</i> WHERE <i>sloupec</i> LIKE <b>řetězecPoužívajícíWildcard</b>;</p>
<br>
<p>Wildcard znaky:</p>
<ul>
    <li><b>%</b> Reprezentuje nula a více znaků</li>
    <li><b>_</b> Reprezentuje jeden znak</li>
    <li><i>znaky<b>%</b></i> Začíná znaky před procentem</li>
    <li><b>%</b><i>znaky</i> Končí znaky po procentu</li>
    <li><b>%</b><i>znaky</i><b>%</b> Znaky mezi procenty se nachází kdekoli v řetězci</li>
</ul>

<p>Databáze, která bude použita pro příklad:</p>
<table>
    <tr>
        <th>id</th>
        <th>gameName</th>
    </tr>
    <tr>
        <td>0</td>
        <td>The Witcher</td>
    </tr>
    <tr>
        <td>1</td>
        <td>The Witcher 2: Assassin of Kings</td>
    </tr>
    <tr>
        <td>2</td>
        <td>The Witcher 3: Wild Hunt</td>
    </tr>
    <tr>
        <td>3</td>
        <td>Tomb Raider</td>
    </tr>
    <tr>
        <td>4</td>
        <td>Rise of the Tomb Raider</td>
    </tr>
    <tr>
        <td>5</td>
        <td>Shadow of the Tomb Raider</td>
    </tr>
    <tr>
        <td>6</td>
        <td>Bioshock 1</td>
    </tr>
    <tr>
        <td>7</td>
        <td>Bioshock 2</td>
    </tr>
    <tr>
        <td>8</td>
        <td>Bioshock Infinite</td>
    </tr>
    <tr>
        <td>9</td>
        <td>WoT</td>
    </tr>
    <tr>
        <td>10</td>
        <td>WoW</td>
    </tr>
</table>
<p>Příklad query, která vybere jakoukoli Bioshock hru z tabulky (použití % wildcardu)</p>
<p class="code">SELECT * FROM <i>games</i> WHERE <i>gameName</i> LIKE <b>"Bioshock%"</b>;</p>
<p>Příklad query, která vybere jakoukoli Tomb Raider hru z tabulky (použití % wildcardu)</p>
<p class="code">SELECT * FROM <i>games</i> WHERE <i>gameName</i> LIKE <b>"%Tomb Raider"</b>;</p>
<p>Příklad query, která vybere jakoukoli Serious Sam hru z tabulky (použití _ wildcardu)</p>
<p class="code">SELECT * FROM <i>games</i> WHERE <i>gameName</i> LIKE <b>"Serious Sam _"</b>;</p>
<p>Příklad query, která vybere WoW a WoT z tabulky (použití _ wildcardu)</p>
<p class="code">SELECT * FROM <i>games</i> WHERE <i>gameName</i> LIKE <b>"Wo_"</b>;</p>
<br>
<p>Wildcardy se dají kombinovat.</p>

<h2>8. Unions</h2>
<p>Operátor UNION spojí výsledky dvou a více dotazů.</p>
<p><b>Reminder: Dotazy nemusí být (a obvykle nejsou) ze stejné tabulky</b></p>
<p>Při práci s tímto operátorem platí dvě pravidla:</p>
<ul>
    <li>Všechny dotazy musí vracet shodný počet sloupců</li>
    <li>Všechny dotazy musí vracet sloupce se shodnými datovými typy (První dotaz vrací VARCHAR a INT, druhý musí taktéž
    vracet VARCHAR a INT, a to ve stejném pořadí).</li>
</ul>
<p>Vzor použití:</p>
<p class="code"><b>DOTAZ1</b> UNION <b>DOTAZ2</b>;</p>
<p>
    Příklad, který vybere jména her, id developerů z tabulky games a jména enginů, id developerů z tabulky developers,
    následně je seřadí podle id developera.
</p>
<p class="code">SELECT <i>games.gameName, games.idDeveloper</i> FROM <i>games</i> UNION SELECT
    <i>developers.developerEngine, developers.idDeveloper</i> FROM <i>developers</i> ORDER by <i>idDeveloper</i>;</p>

<h2>9. Joins</h2>
<p>Spojují data z dvou a více tabulek, pain.</p>
<p>JOIN kombinuje data z řad různých tabulek, pokud je splněna určitá podmínka.</p>
<p>Příklad, který vybere data ze tří tabulek a spojí je dle hodnot id jednotlivých řad:</p>
<p class="code">
    SELECT <i>games.gameName, companies.idCompany, companies.companyName, games.idDeveloper,
    developers.developerEngine</i> FROM <i>games</i><br> JOIN <i>developers</i> ON
    <b>games.idDeveloper = developers.idDeveloper</b><br>
    JOIN <i>companies</i> ON <b>developers.idCompany = companies.idCompany</b>;
</p>
<p>Existuje více typů JOINů, je to komplikované, nemá smysl to rozepisovat, Google that shit.</p>

<h2>10. Nested queries</h2>
<p>
    Nested queries provádějí dotazy, které se neaplikují na celou tabulku, nýbrž na výsledek jiného dotazu.
Používají se při práci s dvěma či více tabulkami.
</p>
<p>Obecný tvar syntaxe:</p>
<p class="code">SELECT <i>sloupec1, sloupec2....</i> FROM <i>tabulka</i><br>WHERE <i>sloupec</i> in (<br>SELECT <i>sloupec</i>
    FROM <i>tabulka</i><br>WHERE <b>podminka</b><br>);</p>
<br>
<p>
    Příklad, který vybere jméno a žánr hry z tabulky games u her, které developer udělal v Unreal Enginu či Crystal Tools
    (data nacházející se v tabulce developer) :
</p>
<p class="code">
    SELECT <i>games.gameName, games.gameGenre</i> FROM <i>games</i><br>
    WHERE <i>games.idDeveloper</i> IN (<br>
    SELECT <i>developers.idDeveloper</i> FROM <i>developers</i><br>
    WHERE <i>developers.developerEngine</i> = "Crystal Tools" OR <i>developers.developerEngine</i> = "Unreal Engine"<br>
    );
</p>

<br>
<h1>Další databázové věci</h1>
<h2>1. ON DELETE</h2>
<p>
    Constraint ON DELETE se používá u <b>cizích klíčů</b>. Zajišťuje, že při smazání řádku, na který referuje cizí klíč,
    nedojde k problému s databází.
</p>
<p>Obecný tvar: </p>
<p class="code">
    .....<br>
    FOREIGN KEY(<i>sloupec</i>) REFERENCES <b>tabulka</b>(<i>sloupec</i>) ON DELETE SET NULL; <br>
</p>
<p class="code">
    .....<br>
    FOREIGN KEY(<i>sloupec</i>) REFERENCES <b>tabulka</b>(<i>sloupec</i>) ON DELETE SET CASCADE; <br>
</p>

<p>
    Pokud je ON DELETE nastaveno na NULL, do cizího klíče bude při smazání záznamu, na který klíč referuje,
    nahrána hodnota <b>NULL</b>, což předejde referenci na neexistující řádek tabulky.
    Pokud je ON DELETE nastaveno na <b>CASCADE</b>, dojde při smazání záznamu, na který klíč referuje,
    ke smazání daného řádku tabulky.
</p>

<h2>2. Transakce</h2>
<p>
    Transakce jsou skupiny SQL dotazů. Při úspěšném provedení všech dotazů jsou transakce prováděný, při selhání
    alespoň jednoho dotazu prováděny nejsou. Je možno je ovládat pomocí keywordů COMMIT, ROLLBACK, SAVEPOINT...
</p>
<p>Transakce respektují princip ACID:</p>
<ul>
    <li>A - <b>Atomicity</b> -> Data jsou dělena na nejmenší možné celky</li>
    <li>C - <b>Consistency</b> -> Veškeré modifikace dat musí odpovídat předepsaným pravidlům, constraintům, kaskádám,
        triggerům...</li>
    <li>I - <b>Isolation</b> -> Data jsou od sebe izolována, databáze může provádět více operací <b>(?)</b></li>
    <li>D - <b>Durability</b> -> Změny provedené v databázi jsou trvanlivé </li>
</ul>

<h2>3. Normalizace databází</h2>
<p>Existuje asi 6 forem normalizace databáze, do DIS jsou však potřeba jen tři.</p>
<h3>Forma 1</h3>
<p>
    Forma jedna říká, že data musí být <b>unikátní</b> (žádné duplicitní záznamy) a musí dodržovat princip
    <b>atomicity</b> (data musí být rozdělena do co nejmenších jednotek).
</p>
<p>Před normalizací:</p>
<table>
    <tr>
        <th>Name</th>
    </tr>
    <tr>
        <td>Richard Stallman</td>
    </tr>
</table>

<p>Po normalizaci</p>
<table>
    <tr>
        <th>Name</th>
        <th>Surname</th>
    </tr>
    <tr>
        <th>Richard</th>
        <th>Stallman</th>
    </tr>
</table>

<h3>Forma 2</h3>
<p>
    Pro splnění formy 2 musí databáze splňovat všechny předešlé formy a tabulky musí mít jeden sloupec, ve kterém se
    nachází primární klíč.
</p>
<p>Před normalizací:</p>
<table>
    <tr>
        <th>Name</th>
        <th>Surname</th>
    </tr>
    <tr>
        <td>Richard</td>
        <td>Stallman</td>
    </tr>
</table>
<p>Po normalizaci:</p>
<table>
    <tr>
        <th>Id</th>
        <th>Name</th>
        <th>Surname</th>
    </tr>
    <tr>
        <td>1</td>
        <td>Richard</td>
        <td>Stallman</td>
    </tr>
</table>

<h3>Forma 3</h3>
<p><a href="https://en.wikipedia.org/wiki/Third_normal_form">Raději wiki</a></p>
</body>
</html>